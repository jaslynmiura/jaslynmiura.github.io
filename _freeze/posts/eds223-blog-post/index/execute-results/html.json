{
  "hash": "a0361a1f6dcf6809a76fd5ef4dd24b41",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Determining Exclusive Economic Zones for Marine Aquaculture Species\"\ndescription: \"Spatial analysis of suitable habitat areas along the west coast (USA) for marine aquaculture\"\ndate: 2025-11-27\ncategories: [MEDS, R]\noutput:\n  distill::distill_article:\n    toc: true\n    code_folding: true\n    self_contained: false\nimage: images/aquaculture.jpg\ncitation:\n   url: https://jaslynmiura.github.io/posts/eds223-blog-post/\n# draft: true\n# draft-mode: linked # hides the post on the listing page, the url exists just hides it from main website.\n# bibliography: references.bib\n---\n\nMarine aquaculture can play a vital role in the global food supply. Using the ideal depth range and temperature range of different species, we can identify areas within the designated Exclusive Economic Zones along the west coast that would be suitable for marine aquaculture.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nlibrary(tidyverse)\nlibrary(terra)\nlibrary(sf)\nlibrary(tmap)\nlibrary(paletteer)\nlibrary(maptiles) \nlibrary(testthat)\nlibrary(kableExtra) \nlibrary(knitr)\n```\n:::\n\n\n## Data Cleaning\n\n*NOTE: When conducting a spatial analyses, we often want to ensure that our spatial objects have the same coordinate reference systems, resolutions, extents, etc. If statements and unit checks can be written within our code to check these conditions. These \"gut checks\" were written within the code folds.*\n\nFor this analysis, we'll be using Sea Surface Temperature rasters from 2008-2012. These rasters were obtained from the NOAA’s 5km Daily Global Satellite Sea Surface Temperature Anomaly v3.1. We'll first stack the rasters into a single-multilayer raster. We will then calculate the mean sea surface temperature value for each cell across the five years. Therefore, each cell within `avg_sst_rast` represents the average sea surface temperature from 2008 to 2012 at that location. We'll also convert the temperature units from Kelvin to Celsius by subtracting 273.15, using raster algebra\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load in Sea Surface Temperature rasters.\nsst_08 <- rast(here::here('posts', 'eds223-blog-post', 'data', 'average_annual_sst_2008.tif'))\nsst_09 <- rast(here::here('posts', 'eds223-blog-post', 'data', 'average_annual_sst_2009.tif'))\nsst_10 <- rast(here::here('posts', 'eds223-blog-post', 'data', 'average_annual_sst_2010.tif'))\nsst_11 <- rast(here::here('posts', 'eds223-blog-post', 'data', 'average_annual_sst_2011.tif'))\nsst_12 <- rast(here::here('posts', 'eds223-blog-post', 'data', 'average_annual_sst_2012.tif'))\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Stacking the 2008, 2009, 2010, 2011, and 2012 rasters.\nsst <- c(sst_08, sst_09, sst_10, sst_11, sst_12)\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Find the average SST of the stacked layers.\navg_sst_rast <- mean(sst)\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Convert the average SST from Kelvin to Celsius, by subtracting 273.15\navg_sst_rast <- avg_sst_rast - 273.15\n```\n:::\n\n\nDepth is another parameter we need for our analysis. This data was obtained from the General Bathymetric Chart of the Oceans (GEBCO). First, we'll crop the raster to match the extent of the `avg_sst_rast`, to ensure that both rasters are within the same study area. We also want to make sure that the resolution of the rasters are the same. So we will resample the cropped depth raster to match the resolution of the `avg_sst_rast`, using the nearest neighbor method. This method assigns each output cell the value of the closest input cell, therefore the depth value in the `depth_resample` raster is simply the value from the nearest pixel in the original `depth` raster.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Loading the depth raster.\ndepth <- rast(here::here('posts', 'eds223-blog-post', 'data', 'depth.tif'))\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\n# Check if coordinate reference systems match.\nif(crs(avg_sst_rast) == crs(depth)) {\n  print(\"Coordinate reference systems match\")\n} else{\n  warning(\"Updating coordinate reference systems to match\")\n  # transform data to match\n  depth <- project(depth, avg_sst_rast)\n}\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Updating coordinate reference systems to match\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Cropping the depth raster to match the extent of the SST raster.\ndepth_crop <- terra::crop(depth, avg_sst_rast)\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Resampling the depth raster, using the nearest neighbor approach\ndepth_resample <- resample(depth_crop, y = avg_sst_rast, method = \"near\")\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\n# Check that the depth_resample and avg_sst_rast match in resolution, extent, and crs.\nif(crs(avg_sst_rast) == crs(depth_resample)) {\n  print(\"Coordinate reference systems match!\")\n} else{\n  warning(\"Updating coordinate reference systems to match\")\n  # Transform data to match\n  avg_sst_rast <- project(avg_sst_rast, depth_resample)\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Coordinate reference systems match!\"\n```\n\n\n:::\n\n```{.r .cell-code  code-fold=\"true\"}\nif(resolution(avg_sst_rast) == resolution(depth_resample)) {\n  print(\"Resolutions match!\")\n} else{\n  print(\"Resolutions do not match!\")\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Resolutions match!\"\n```\n\n\n:::\n\n```{.r .cell-code  code-fold=\"true\"}\nif(ext(avg_sst_rast) == ext(depth_resample)) {\n  print(\"Extents match!\")\n} else{\n  print(\"Extents do not match!\")\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Extents match!\"\n```\n\n\n:::\n:::\n\n\n## Spatial Analysis\n\nWe'll now reclassify our rasters, given certain parameters, using a reclassification matrix. Within the temperature matrix we are setting cells that have a sea surface temperature of 11-30 degrees Celsius as 1, and any other values as 0. Within the depth matrix we are setting cells that have a depth of -70-0 meters to 1, and any other values as 0. By reclassifying our rasters, we can then multiple the reclassified rasters to create a new raster, `suitable_eez`, which only selects the areas where 1x1=1.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Reclassify avg_sst_rast into locations that are suitable for oysters.\nrcl_temp <- matrix(c(-Inf, 11, 0,\n                11, 30, 1,\n                30, Inf, 0),\n              ncol = 3, byrow = TRUE)\n\nreclassified_sst <- classify(avg_sst_rast, rcl = rcl_temp)\n\nreclassified_sst[is.na(reclassified_sst)] <- 0\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Reclassify depth into locations that are suitable for oysters.\nrcl_depth <- matrix(c(-Inf, -70, 0,\n                -70, 0, 1,\n                0, Inf, 0),\n              ncol = 3, byrow = TRUE)\n\nreclassified_depth <- classify(depth_resample, rcl = rcl_depth)\n\nreclassified_depth[is.na(reclassified_depth)] <- 0\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Multiply depth and temperature rasters to find suitable areas for both conditions.\nsuitable_eez <- (reclassified_depth)*(reclassified_sst)\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Loading boundaries using west coast Exclusive Economic Zones.\nwest_coast <- st_read(here::here('posts', 'eds223-blog-post', 'data', 'wc_regions_clean.shp'))\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\n# Check if the coordinate systems match.\nif(crs(suitable_eez) == crs(west_coast)) {\n  print(\"Coordinate reference systems match\")\n} else{\n  warning(\"Updating coordinate reference systems to match\")\n  # transform data to match\n  west_coast <- st_transform(west_coast, crs = st_crs(suitable_eez))\n}\n```\n:::\n\n\n### Determine the most suitable EEZ.\n\n::: {.cell}\n\n```{.r .cell-code}\n# Masking the suitable_eez raster to the west_coast regions.\nsuitable_eez_mask <- mask(suitable_eez, west_coast)\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Vectoirize west_coast boundary.\nwest_coast_vect <- vect(west_coast)\n\n# Select the number suitable cells within west coast EEZs.\nregion_count <- terra::extract(suitable_eez_mask, west_coast_vect, \n                               fun = \"sum\") %>% \n  rename(suitable_cell_count = depth)\n\n# Use cellSize to change the units to kilometers.\ngrid_cell_km <- cellSize(suitable_eez_mask, unit = \"km\")\n\n# Convert cells of mask raster into km^2.\nsuitable_area_rast <- suitable_eez_mask * grid_cell_km\n\n# Calculate the area of suitable cells within west coast EEZ.\nregion_area <- terra::extract(suitable_area_rast, west_coast_vect, \n                              fun = sum, na.rm = TRUE) %>% \n  rename(suitable_area_oysters = depth)\n\n# Creating bins for suitable area.\nregion_area$suitable_area_bin_oysters <- cut(\n  region_area$suitable_area_oysters,\n  breaks = c(0, 1000, 2000, 3000, 4000),\n  include.lowest = TRUE,\n  right = FALSE,\n  labels = c(\"0–1000\", \"1000–2000\", \"2000–3000\", \"3000–4000\"))\n\n# Joining the suitable region area to the west_coast boundary dataframe.\nwest_coast <- west_coast %>%\n  left_join(region_area, by = c(\"rgn_id\" = \"ID\")) \n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\n# Creating a table of suitable area in each region.\nsuitable_df <- west_coast %>% \n  select(\"rgn\", \"suitable_area_oysters\") %>% \n  st_drop_geometry() %>% \n  kable(col.names = c(\"Region\", \"Suitable Area (km²)\"),\n        caption = \"Table 1: Suitable Area (km²) for Oysters\")\nsuitable_df\n```\n\n::: {.cell-output-display}\n\n\nTable: Table 1: Suitable Area (km²) for Oysters\n\n|Region              | Suitable Area (km²)|\n|:-------------------|-------------------:|\n|Oregon              |           1028.9013|\n|Northern California |            194.1284|\n|Central California  |           3656.8195|\n|Southern California |           3062.2031|\n|Washington          |           2435.9250|\n\n\n:::\n:::\n\nThis table identifies the exact area that is determined to be suitable for Oysters. Looking at our map it may appear that the Central and Southern California regions both have the same amount of area suitable for Oysters, but this table tells us that the prime zone would be the Central California.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create a map of the suitable area within each Exclusive Economic Zone.\ntm_graticules() +\ntm_basemap(\"OpenStreetMap\") +\ntm_shape(west_coast) +\n  tm_polygons(fill = \"suitable_area_bin_oysters\",\n              fill.scale = tm_scale(values = \"brewer.pu_rd\"),\n              fill.legend = tm_legend(expression(\"Area km\"^{2}))) +\n  tm_title(text = \"Suitable Area of Oysters\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-19-1.png){width=672}\n:::\n:::\n\n\nThis map compares the suitability of each region. Highlighting which regions have the highest area in km$^2$ that can support a given species, in this case we are looking at oysters. \n\n## Identifying regions for other marine species\nTo identify other suitable regions for other marine species, a function was created, where only parameters required are the depth and temperature ranges, and the species name we are interested in. This function will create a map of new species we are interested in. The map identifies the regions along the west coast that contains the largest suitable areas for the marine species.\n\n![](index_files/figure-html/unnamed-chunk-20-1.png){width=672}\n\nTable: Table 1: Suitable Area (km²) for Red Abalone\n\n|Region              | Suitable Area (km²)|\n|:-------------------|-------------------:|\n|Oregon              |            504.4047|\n|Northern California |            308.5819|\n|Central California  |            732.7807|\n|Southern California |            713.2249|\n|Washington          |           1687.8526|\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}